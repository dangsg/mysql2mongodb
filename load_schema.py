import json
from utilities import extract_dict

def read_schema_file(schema_file):
	"""Read all schemas from file which was generated by SchemaCrawler"""
	with open(schema_file) as json_file:
		db_schema = json.load(json_file)
	return db_schema

def get_tables_schema(db_schema):
	"""Return only field "tables" from "catalog" of schema""" 
	return db_schema["catalog"]["tables"]

def extract_tables_schema(tables_schema, extracted_keys_list = ["@uuid", "name", "columns", "foreign-keys"]):
	"""Extract only useful fields from tables schema""" 
	ite_func = extract_dict(extracted_keys_list)
	return list(map(ite_func, tables_schema))

def get_tables_relations(extracted_tables_schema):
	"""
	Get relations between MySQL tables.
	Result will be a dictionary which has uuids (of relation, defined by SchemaCrawler) as keys, and values including:
	- source: Name of table which holds primary key of relation
	- dest: Name of table which holds foreign key of relation
	"""
	relations_dict = {}
	for table in extracted_tables_schema:
		for foreign_key in table["foreign-keys"]:
			if(isinstance(foreign_key, dict)):
				relations_dict[str(foreign_key["@uuid"])] = {}
				relations_dict[str(foreign_key["@uuid"])]["source"] = table["name"]
				relations_dict[str(foreign_key["@uuid"])]["dest"] = table["name"]
	for table in extracted_tables_schema:
		for foreign_key in table["foreign-keys"]:
			if(isinstance(foreign_key, str)):
				relations_dict[str(foreign_key)]["dest"] = table["name"]
	return relations_dict

def get_tables_name_list(schema_file):
	"""Get list of tables' name"""
	db_schema = read_schema_file(schema_file)
	tables_schema = get_tables_schema(db_schema)
	extracted_tables_schema = extract_tables_schema(tables_schema)
	table_name_list = list(map(lambda table: table["name"], extracted_tables_schema))
	return table_name_list

def specify_sequence_of_migrating_tables(schema_file):
	"""
	Specify sequence of migrating tables from MySQL. The sequence must guarantee all tables and data within them will be migrated effectively and efficiently.
	We will make a tree to determine which order each table should have.
	Result will be a dictionary which have tables' names as key and orders in sequence as values.
	The lower mark table have, the higher order get, and data of it will be migrate previously.
	"""
	db_schema = read_schema_file(schema_file)
	tables_schema = get_tables_schema(db_schema)
	extracted_tables_schema = extract_tables_schema(tables_schema)
	tables_relations = get_tables_relations(extracted_tables_schema)
	tables_name_list = get_tables_name_list(schema_file)

	refering_tables_set = set(map(lambda ele: ele["dest"], tables_relations.values()))
	root_nodes = set(tables_name_list) - refering_tables_set

	node_seq = dict.fromkeys(tables_name_list, -1)
	node_seq.update(dict.fromkeys(root_nodes, 0))

	# Eliminate self reference relation
	tables_relations_list = list(filter(lambda rel: rel["source"] != rel["dest"], list(tables_relations.values())))

	current_mark = 0
	while(current_mark <= max(node_seq.values())):
		source_nodes = set(filter(lambda key: node_seq[str(key)] == current_mark, node_seq.keys()))
		for source_node in source_nodes:
			for direction in tables_relations_list:
				if(direction["source"] == source_node):
					if(node_seq[direction["dest"]] < current_mark + 1):
						node_seq[direction["dest"]] = current_mark + 1
					direction["source"] = None #TODO: Find a more effective way to eliminate retrieved nodes
		current_mark = current_mark + 1
	return node_seq

if __name__ == '__main__':
	node_sequence = specify_sequence_of_migrating_tables('schema.json')
	print(node_sequence)